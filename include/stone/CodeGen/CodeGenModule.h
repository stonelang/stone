#ifndef STONE_CODEGEN_CODEGENMODULE_H
#define STONE_CODEGEN_CODEGENMODULE_H

#include "stone/AST/ASTVisitor.h"
#include "stone/AST/Diagnostics.h"
#include "stone/AST/Module.h"
#include "stone/CodeGen/CodeGenBuilder.h"
#include "stone/CodeGen/CodeGenContext.h"
#include "stone/CodeGen/CodeGenPassManager.h"

#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Target/TargetMachine.h"

namespace llvm {
class Type;
class FunctionType;
class IntegerType;
class PointerType;
} // namespace llvm

namespace stone {
class Type;
class SourceFile;
class AutoDecl;
class Decl;
class ConstructorDecl;
class DestructorDecl;
class InterfaceDecl;
class VarDecl;
class CodeGenModule;
class CodeGenFunction;
class FunctionDecl;

class CodeGenDebugInfo final {
public:
};

class CodeGenConstant final {
public:
  CodeGenModule &cgm;
  CodeGenFunction *cgf;

public:
  CodeGenConstant(const CodeGenConstant &other) = delete;
  CodeGenConstant &operator=(const CodeGenConstant &other) = delete;

public:
  CodeGenConstant(CodeGenModule &cgm, CodeGenFunction *cgf = nullptr);

  ~CodeGenConstant();
};

class CodeGenTypeInfo {
  llvm::Type *ty;

public:
  CodeGenTypeInfo(llvm::Type *ty) : ty(ty) {}
  // virtual ~CodeGenTypeInfo();
};

class CodeGenModule final : public ASTVisitor<CodeGenModule> {
public:
  // The ABI version of the Stone data generated by this file.
  static const uint32_t StoneABIVersion = 1;

public:
  llvm::Type *VoidTy;

  llvm::IntegerType *Int8Ty;  /// i8
  llvm::IntegerType *Int16Ty; /// i16
  llvm::IntegerType *Int32Ty; /// i32
  llvm::IntegerType *Int64Ty; /// i64
  llvm::IntegerType *IntTy;   /// int
  llvm::IntegerType *CharTy;  /// char

  llvm::PointerType *Int8PtrTy;  /// i16*
  llvm::PointerType *Int16PtrTy; /// i16*
  llvm::PointerType *Int32PtrTy; /// i32*
  llvm::PointerType *Int64PtrTy; /// i64*
  llvm::PointerType *IntPtrTy;   ///  int*

  // LLVM Address types
  llvm::IntegerType *RelativeAddressTy;
  llvm::PointerType *RelativeAddressPtrTy;

  // llvm::CallingConv::ID CCC;          /// standard C calling convention
  // llvm::CallingConv::ID DefaultCC;     /// default calling convention

private:
  CodeGenContext &codeGen;
  SourceFile *sourceFile;
  llvm::Module &llvmModule;
  CodeGenPassManager codeGenPassMgr;
  CodeGenBuilder codeGenBuilder;
  ModuleNameAndOuptFileName moduleNameAndOuptFileName;
  std::unique_ptr<clang::CodeGenerator> clangCodeGen;
  const llvm::DataLayout dataLayout;
  std::unique_ptr<clang::CodeGenerator> CreateClangCodeGen();

public:
  /// The \p sourceFile is used when the llvm module is generated in a
  /// doing multi-threaded and whole-module compilation -- null otherwise.
  CodeGenModule(CodeGenContext &codeGen, SourceFile *sourceFile,
                ModuleNameAndOuptFileName moduleNameAndOuptFileName);

public:
  /// Builtin types referenced by types in this module when emitting
  /// reflection metadata.
  // llvm::SetVector<CanType> BuiltinTypes;

public:
  CodeGenContext &GetCodeGenContext() { return codeGen; }
  SourceFile *GetSourceFile() { return sourceFile; }
  bool HasSourceFile() { return sourceFile != nullptr; }
  llvm::Module &GetLLVMModule() { return llvmModule; }

  ModuleNameAndOuptFileName GetModuleNameAndOuptFileName() {
    return moduleNameAndOuptFileName;
  }
  CodeGenPassManager &GetCodeGenPassManager() { return codeGenPassMgr; }
  clang::CodeGenerator &GetClangCodeGen() { return *clangCodeGen; }
  CodeGenBuilder &GetCodeGenBuilder() { return codeGenBuilder; }

  const llvm::DataLayout &GetDataLayout() { return dataLayout; }

public:
  void EmitSourceFile(SourceFile &sf);
  void EmitGlobalDecl(Decl *d);
  void EmitDecl(Decl *d);

  void EmitFunctionDecl(FunctionDecl *FD);
  void EmitFunctionDefinition();
  void EmitFunDecl(FunDecl *D, llvm::GlobalValue *GV);

  void EmitInterfaceDecl(InterfaceDecl *d);
  void EmitStructDecl(StructDecl *d);
  void EmitClassDecl(ClassDecl *d);
  void EmitEnumDecl(EnumDecl *d);
  void EmitVarDecl(VarDecl *d);
  void EmitAutoDecl(AutoDecl *d);

  void EmitConstructorDecl(ConstructorDecl *d);
  void EmitDestructorDecl(DestructorDecl *dd);

public:
  // || TYPE RESOLUTION ||
  llvm::Type *GetType(const Type ty);
  llvm::FunctionType *GetFunctionType(const FunctionDecl *FD);
};

} // namespace stone

#endif
